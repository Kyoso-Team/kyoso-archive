datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

//  _    _
// | |  | |
// | |  | | ___   ___  _ __  ___
// | |  | |/ __| / _ \| '__|/ __|
// | |__| |\__ \|  __/| |   \__ \
//  \____/ |___/ \___||_|   |___/
//

model User {
  id                          Int                          @id @default(autoincrement())
  registeredAt                DateTime                     @default(now())
  updatedAt                   DateTime                     @updatedAt
  isAdmin                     Boolean
  osuUserId                   Int                          @unique
  osuUsername                 String                       @unique @db.VarChar(16)
  isRestricted                Boolean
  discordUserId               String                       @unique @db.VarChar(19)
  discordUsername             String                       @db.VarChar(32)
  discordDiscriminator        Int                          @db.SmallInt
  apiKey                      String                       @db.Char(24)
  freeServicesLeft            Int                          @default(3) @db.SmallInt
  // Auth
  osuAccessToken              String
  osuRefreshToken             String
  discordAccesstoken          String
  discordRefreshToken         String
  // Settings
  theme                       UserTheme                    @default(Dark)
  showDiscordTag              Boolean                      @default(true)
  // Relations
  country                     Country                      @relation(fields: [countryId], references: [id])
  countryId                   Int
  asStaffMember               StaffMember[]
  asPlayer                    Player[]
  purchases                   Purchase[]
  notifications               Notification[]
  submittedIssues             Issue[]
  deletedTournamentNotifs     NotifTournamentDeleted[]
  grantedHostNotifsAsNewHost  NotifGrantedTournamentHost[] @relation("newHost")
  grantedHostNotifsAsPrevHost NotifGrantedTournamentHost[] @relation("previousHost")
  staffChangNotifs            NotifStaffChange[]
  teamChangeAsUser            NotifTeamChange[]            @relation("affectedUser")
  teamChangeAsKicker          NotifTeamChange[]            @relation("kicker")
  asPickemUser                PickemUser[]
}

enum UserTheme {
  Light
  Dark
}

model Country {
  id    Int    @id @default(autoincrement())
  users User[]
  name  String @db.VarChar(35)
  code  String @unique @db.Char(2)
}

model Purchase {
  id              Int                 @id @default(autoincrement())
  purchasedAt     DateTime            @default(now())
  cost            Float
  paypalOrderId   String              @db.VarChar(20)
  services        TournamentService[]
  purchasedBy     User                @relation(fields: [purchasedById], references: [id], onDelete: Cascade)
  purchasedById   Int
  forTournament   Tournament?         @relation(fields: [forTournamentId], references: [id])
  forTournamentId Int?
}

//  _______                                                         _
// |__   __|                                                       | |
//    | |  ___   _   _  _ __  _ __    __ _  _ __ ___    ___  _ __  | |_  ___
//    | | / _ \ | | | || '__|| '_ \  / _` || '_ ` _ \  / _ \| '_ \ | __|/ __|
//    | || (_) || |_| || |   | | | || (_| || | | | | ||  __/| | | || |_ \__ \
//    |_| \___/  \__,_||_|   |_| |_| \__,_||_| |_| |_| \___||_| |_| \__||___/
//

model Tournament {
  id                    Int                    @id @default(autoincrement())
  name                  String                 @unique @db.VarChar(50)
  acronym               String                 @db.VarChar(8)
  lowerRankRange        Int
  upperRankRange        Int
  goPublicOn            DateTime? // Date in which the tournament will be displayed on the site for anyone to view
  concludesOn           DateTime? // Date in which the tournament can no longer be modified (its settings, pools, schedules, etc.)
  playerRegsOpenOn      DateTime?
  playerRegsCloseOn     DateTime?
  staffRegsOpenOn       DateTime?
  staffRegsCloseOn      DateTime?
  teamSize              Int                    @default(1) @db.SmallInt
  teamPlaySize          Int                    @default(1) @db.SmallInt
  hasBanner             Boolean                @default(false)
  useBWS                Boolean
  rules                 String? // BBCode
  type                  TournamentType
  services              TournamentService[]
  // Links
  forumPostId           Int?
  discordInviteId       String?                @db.VarChar(12)
  mainSheetId           String?                @db.VarChar(45)
  twitchChannelName     String?                @db.VarChar(25)
  youtubeChannelId      String?                @db.VarChar(25)
  twitterHandle         String?                @db.VarChar(15)
  donationLink          String?
  websiteLink           String?
  // Ref settings
  pickTimerLength       Int                    @default(120)
  startTimerLength      Int                    @default(10)
  doublePickAllowed     Boolean                @default(false)
  doubleBanAllowed      Boolean                @default(false)
  alwaysForceNoFail     Boolean                @default(true)
  rollRules             String?
  freeModRules          String?
  warmupRules           String?
  lateProcedures        String?
  banOrder              BanOrder               @default(ABABAB)
  winCondition          WinCondition           @default(Score)
  // Relations
  staffRoles            StaffRole[]
  staffMembers          StaffMember[]
  inPurchases           Purchase[]
  modMultipliers        ModMultiplier[]
  stages                Stage[]
  rounds                Round[]
  suggestedMaps         SuggestedMap[]
  pooledMaps            PooledMap[]
  lobbies               Lobby[]
  teams                 Team[]
  players               Player[]
  potentialMatches      PotentialMatch[]
  pickemUsers           PickemUser[]
  predictionSubmissions PredictionSubmission[]
  prizes                Prize[]
}

enum TournamentType {
  Teams
  Draft
  Solo
}

enum WinCondition {
  Score
  Accuracy
  Combo
  Misses
}

enum BanOrder {
  ABABAB
  ABBAAB
}

enum TournamentService {
  Registrations // Specifically player and registrations
  Mappooling
  Referee
  Stats
  Pickems
}

model Prize {
  id               Int        @id @default(autoincrement())
  type             PrizeType
  positions        Int[]      @db.SmallInt // A single element array for a single place. Example: 1st, 2nd, 3rd place
  // A range of positions in case of multiple placements sharing the same prize. Example: Top 4-6
  trophy           Boolean // Physical trophy
  medal            Boolean // Physical medal
  badge            Boolean
  banner           Boolean
  cash             Float      @default(0)
  cashMetric       CashMetric @default(Fixed)
  cashCurrency     String     @default("USD") @db.Char(3)
  items            String[]   @db.VarChar(25)
  osuSupporter     Int        @db.SmallInt // In months
  tournament       Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId     Int
  awardedToPlayers Player[]
  awardedToTeams   Team[]
}

enum PrizeType {
  Tournament
  Pickems
}

enum CashMetric {
  Fixed
  Percent
}

model Stage {
  id           Int         @id @default(autoincrement())
  format       StageFormat
  order        Int         @db.SmallInt
  isMainStage  Boolean     @default(false) // Example: If double elimination is set as the "main stage" then the tournament will be listed as double elimination
  tournament   Tournament  @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId Int
  rounds       Round[]

  @@unique([tournamentId, format])
}

enum StageFormat {
  Groups
  Swiss
  Qualifiers
  SingleElim
  DoubleElim
  BattleRoyale
}

model Round {
  id                     Int                     @id @default(autoincrement())
  name                   String                  @db.VarChar(20)
  targetStarRating       Float
  mappoolState           MappoolState            @default(Private)
  publishSchedules       Boolean                 @default(false)
  publishStats           Boolean                 @default(false)
  stage                  Stage                   @relation(fields: [stageId], references: [id], onDelete: Cascade)
  stageId                Int
  tournament             Tournament              @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId           Int
  standardRound          StandardRound?
  qualfierRound          QualifierRound?
  battleRoyaleRound      BattleRoyaleRound?
  modpools               Modpool[]
  suggestedMaps          SuggestedMap[]
  pooledMaps             PooledMap[]
  lobbies                Lobby[]
  teamScores             TeamScore[]
  playerScores           PlayerScore[]
  roundPublicationNotifs NotifRoundPublication[]
  predictionSubmissions  PredictionSubmission[]

  @@unique([name, tournamentId])
}

enum MappoolState {
  Private
  Playtesting
  Public
}

// Applies to: Groups, swiss, single and double elim.
model StandardRound {
  bestOf   Int   @db.SmallInt
  banCount Int   @db.SmallInt
  round    Round @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId  Int   @id @unique
}

model QualifierRound {
  publishMpLinks  Boolean              @default(false)
  runCount        Int // How many times will the mappool be played
  summarizeRunsAs QualifierRunsSummary
  round           Round                @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId         Int                  @id @unique
}

enum QualifierRunsSummary {
  Average // Calculate the average score for each map in all runs
  Sum // Calculate the sum of scores for each map in all runs
  Best // Get the best score for each map
}

model BattleRoyaleRound {
  playersEliminatedPerMap Int   @db.SmallInt
  round                   Round @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId                 Int   @id @unique
}

//  _____
// |  __ \
// | |__) | ___   __ _  ___
// |  _  / / _ \ / _` |/ __|
// | | \ \|  __/| (_| |\__ \ _
// |_|  \_\\___| \__, ||___/(_)
//                __/ |
//               |___/
//

model StaffRole {
  id           Int               @id @default(autoincrement())
  name         String            @db.VarChar(25)
  color        StaffColor        @default(Slate)
  permissions  StaffPermission[]
  tournament   Tournament        @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId Int
  staffMembers StaffMember[]

  @@unique([name, tournamentId])
}

enum StaffPermission {
  // Prefixes:
  // View: Get data
  // Mutate: Create and update data
  // Delete: Delete data

  // Host can do everything regardless of other permissions, can also delete the tournament. Only one user can have this permission per tournament
  Host
  // Tournament
  MutateTournament
  // Staff
  ViewStaffMembers
  MutateStaffMembers
  DeleteStaffMembers
  // Regs.
  ViewRegs
  MutateRegs
  DeleteRegs
  // Mappool structure
  ViewPoolStructure
  MutatePoolStructure
  // Suggest maps
  ViewPoolSuggestions
  MutatePoolSuggestions
  DeletePoolSuggestions
  // Pool maps
  ViewPooledMaps
  DeletePooledMaps
  // Playtest (provide replays and feedback)
  ViewMapsToPlaytest
  MutateMapsToPlaytest // Can replay and provide feedback
  DeleteMapsToPlaytest
  // Matches
  ViewMatches
  MutateMatches
  DeleteMatches
  RefMatches
  CommentateMatches
  StreamMatches
  // Stats
  ViewStats
  MutateStats // Can calculate stats
  DeleteStats
  // Misc.
  CanPlay // Can play in the tournament
}

enum StaffColor {
  Slate
  Gray
  Red
  Orange
  Yellow
  Lime
  Green
  Emerald
  Cyan
  Blue
  Indigo
  Purple
  Fuchsia
  Pink
}

model StaffMember {
  id                    Int               @id @default(autoincrement())
  roles                 StaffRole[]
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                Int
  tournament            Tournament        @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId          Int
  suggestedMaps         SuggestedMap[]
  pooledMapsSuggested   PooledMap[]       @relation("suggestedBy")
  pooledMaps            PooledMap[]       @relation("pooledBy")
  asReferee             Lobby[]           @relation("referees")
  asStreamer            Lobby[]           @relation("streamers")
  asCommentator         Lobby[]           @relation("commentators")
  pooledMapRatingsGiven PooledMapRating[]

  @@unique([userId, tournamentId])
}

model StaffApplication {
  id                Int                   @id @default(autoincrement())
  title             String
  description       String?
  lookinFor         StaffAppRoles[]
  submissions       StaffAppSubmissions[]
  newStaffAppNotifs NotifNewStaffApp[]
}

model StaffAppRoles {
  id                 Int              @id @default(autoincrement())
  role               String           @db.VarChar(25)
  description        String?
  staffApplication   StaffApplication @relation(fields: [staffApplicationId], references: [id], onDelete: Cascade)
  staffApplicationId Int
}

model StaffAppSubmissions {
  id                 Int              @id @default(autoincrement())
  applyingFor        String[]         @db.VarChar(25)
  staffingExperience String
  additionalComments String?
  staffApplication   StaffApplication @relation(fields: [staffApplicationId], references: [id], onDelete: Cascade)
  staffApplicationId Int
}

model Team {
  id                  Int                 @id @default(autoincrement())
  registeredAt        DateTime            @default(now())
  name                String              @db.VarChar(20)
  inviteId            String              @unique @db.Char(8)
  hasBanner           Boolean             @default(false)
  tournament          Tournament          @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId        Int
  captain             Player              @relation("captain", fields: [captainId], references: [id])
  captainId           Int                 @unique
  prizeWon            Prize?              @relation(fields: [prizeWonId], references: [id])
  prizeWonId          Int?
  players             Player[]            @relation("player")
  asTeam1             Match[]             @relation("team1")
  asTeam2             Match[]             @relation("team2")
  asPotentialTeam1    PotentialMatch[]    @relation("potentialTeam1")
  asPotentialTeam2    PotentialMatch[]    @relation("potentialTeam2")
  qualLobbies         QualLobby[]
  qualMapsPlayed      PlayedQualMap[]
  knockoutLobbies     KnockoutLobby[]
  knockoutMapsPlayed  PlayedKnockoutMap[] @relation("playedTeams")
  knockedOutInLobbies PlayedKnockoutMap[] @relation("knockedOutTeams")
  scores              TeamScore[]
  teamChangeNotifs    NotifTeamChange[]
  inQualPredictions   QualPrediction[]

  @@unique([name, tournamentId])
}

model JoinTeamRequest {
  id                    Int                    @id @default(autoincrement())
  requestedAt           DateTime               @default(now())
  status                JoinTeamRequestStatus  @default(Pending)
  requestedBy           Player                 @relation(fields: [requestedById], references: [id], onDelete: Cascade)
  requestedById         Int
  joinTeamRequestNotifs NotifJoinTeamRequest[]
}

enum JoinTeamRequestStatus {
  Pending // Pending response
  Accepted
  Rejected
}

// If the player is in a team tournament and doesn't have a team, then they're a free agent
model Player {
  id                  Int                 @id @default(autoincrement())
  registeredAt        DateTime            @default(now())
  availability        String              @db.Char(99) // A string that represents the availability between 0 - 23 UTC (24 digits), from Friday to Monday
  // Where each digit can be either 0 (unavailable) or 1 (available)
  // Each day is separated by a period, similarly to an IP address
  tournament          Tournament          @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId        Int
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId              Int
  teamAsCaptain       Team?               @relation("captain")
  team                Team?               @relation("player", fields: [teamId], references: [id])
  teamId              Int?
  prizeWon            Prize?              @relation(fields: [prizeWonId], references: [id])
  prizeWonId          Int?
  asPlayer1           Match[]             @relation("player1")
  asPlayer2           Match[]             @relation("player2")
  asPotentialPlayer1  PotentialMatch[]    @relation("potentialPlayer1")
  asPotentialPlayer2  PotentialMatch[]    @relation("potentialPlayer2")
  qualLobbies         QualLobby[]
  qualMapsPlayed      PlayedQualMap[]
  knockoutLobbies     KnockoutLobby[]
  knockoutMapsPlayed  PlayedKnockoutMap[] @relation("playedPlayers")
  knockedOutInLobbies PlayedKnockoutMap[] @relation("knockedOutPlayers")
  scores              PlayerScore[]
  joinTeamRequests    JoinTeamRequest[]
  inQualPredictions   QualPrediction[]

  @@unique([userId, tournamentId])
}

//  _____               _  _
// |  __ \             | |(_)
// | |__) |___    ___  | | _  _ __    __ _
// |  ___// _ \  / _ \ | || || '_ \  / _` |
// | |   | (_) || (_) || || || | | || (_| |
// |_|    \___/  \___/ |_||_||_| |_| \__, |
//                                    __/ |
//                                   |___/
//

model Modpool {
  id            Int            @id @default(autoincrement())
  category      String         @db.VarChar(3) // "NM", "HD", "TB", etc.
  mods          Mod[]
  order         Int            @db.SmallInt // The order in which the modpools should be presented. Example: NM (1) should go before HD (2)
  mapCount      Int            @db.SmallInt
  round         Round          @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId       Int
  suggestedMaps SuggestedMap[]
  pooledMaps    PooledMap[]

  @@unique([roundId, mods])
  @@unique([roundId, category])
}

enum Mod {
  EZ
  HD
  HR
  SD
  DT
  RX
  HT
  FL
  PF
}

model Beatmapset {
  osuBeatmapsetId Int       @id @unique
  artist          String    @db.VarChar(70)
  title           String    @db.VarChar(180) // https://youtu.be/LnkfOVHkVfo
  mapper          Mapper    @relation(fields: [mapperId], references: [osuUserId], onDelete: Cascade)
  mapperId        Int
  beatmaps        Beatmap[]
}

model Mapper {
  osuUserId   Int          @id @unique
  username    String       @db.VarChar(16)
  beatmapsets Beatmapset[]
}

model Beatmap {
  osuBeatmapId Int            @id @unique
  diffName     String         @db.VarChar(75)
  maxCombo     Int
  // Stats are presented without mods
  bpm          Int            @db.SmallInt
  length       Int // In seconds
  cs           Float
  ar           Float
  od           Float
  hp           Float
  beatmapset   Beatmapset     @relation(fields: [beatmapsetId], references: [osuBeatmapsetId], onDelete: Cascade)
  beatmapsetId Int
  starRatings  StarRating[]
  asSuggestion SuggestedMap[]
  asPooledMap  PooledMap[]
}

// Star rating is kept in DB because it can't be calculated with the data the osu! API provides and to avoid repeated calls for the same data at said API
model StarRating {
  id        Int     @id @default(autoincrement())
  mods      Mod[]
  value     Float
  beatmap   Beatmap @relation(fields: [beatmapId], references: [osuBeatmapId], onDelete: Cascade)
  beatmapId Int
}

model SuggestedMap {
  id                Int          @id @default(autoincrement())
  suggestedSkillset Skillset
  comment           String?
  tournament        Tournament   @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId      Int
  round             Round        @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId           Int
  modpool           Modpool      @relation(fields: [modpoolId], references: [id], onDelete: Cascade)
  modpoolId         Int
  beatmap           Beatmap      @relation(fields: [beatmapId], references: [osuBeatmapId], onDelete: Cascade)
  beatmapId         Int
  suggestedBy       StaffMember? @relation(fields: [suggestedById], references: [id])
  suggestedById     Int?

  @@unique([beatmapId, modpoolId])
}

enum Skillset {
  Consistency
  Streams
  Tech
  Alt
  Speed
  Gimmick
  Rhythm
  Aim
  AwkwardAim
  FlowAim
  Reading
  Precision
  Stamina
  FingerControl
  JackOfAllTrades
}

model PooledMap {
  id                  Int                 @id @default(autoincrement())
  slot                Int // Position in modpool. Example: If slot is 1 and modpool is NM then: NM1
  skillset            Skillset
  comment             String?
  hasBeatmapFile      Boolean             @default(false)
  hasReplay           Boolean             @default(false)
  tournament          Tournament          @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId        Int
  round               Round               @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId             Int
  modpool             Modpool             @relation(fields: [modpoolId], references: [id], onDelete: Cascade)
  modpoolId           Int
  beatmap             Beatmap?            @relation(fields: [beatmapId], references: [osuBeatmapId], onDelete: Cascade)
  beatmapId           Int?
  suggestedBy         StaffMember?        @relation("suggestedBy", fields: [suggestedById], references: [id])
  suggestedById       Int?
  pooledBy            StaffMember?        @relation("pooledBy", fields: [pooledById], references: [id])
  pooledById          Int?
  ratings             PooledMapRating[]
  asPlayedMap         PlayedMap[]
  asBannedMap         BannedMap[]
  asPlayedQualMap     PlayedQualMap[]
  asPlayedKnockoutMap PlayedKnockoutMap[]
  inTeamScores        TeamScore[]
  inPlayerScores      PlayerScore[]

  @@unique([modpoolId, beatmapId])
}

// For playtesting feedback
model PooledMapRating {
  id          Int          @id @default(autoincrement())
  rating      Float // Enjoyment rating from a scale of 0 to 10
  ratedBy     StaffMember? @relation(fields: [ratedById], references: [id])
  ratedById   Int?
  pooledMap   PooledMap    @relation(fields: [pooledMapId], references: [id])
  pooledMapId Int
}

//  _____         __
// |  __ \       / _|
// | |__) | ___ | |_  ___  _ __  ___   ___
// |  _  / / _ \|  _|/ _ \| '__|/ _ \ / _ \
// | | \ \|  __/| | |  __/| |  |  __/|  __/
// |_|  \_\\___||_|  \___||_|   \___| \___|
//

model Lobby {
  id           Int            @id @default(autoincrement())
  localId      String         @db.VarChar(5)
  date         DateTime
  refNotes     String
  osuMpIds     Int[]
  tournament   Tournament     @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId Int
  round        Round          @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId      Int
  match        Match?
  quals        QualLobby?
  knockout     KnockoutLobby?
  referees     StaffMember[]  @relation("referees")
  streamers    StaffMember[]  @relation("streamers")
  commentators StaffMember[]  @relation("commentators")

  @@unique([localId, tournamentId])
}

// Swiss, groups, double and single elim.
model Match {
  rollWinner    Opponent?
  banFirst      Opponent?
  pickFirst     Opponent?
  forfeitFrom   Opponent?
  winner        Opponent?
  lobby         Lobby             @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  lobbyId       Int               @id @unique
  // Used in solo tournaments
  player1       Player?           @relation("player1", fields: [player1Id], references: [id])
  player1Id     Int?
  player2       Player?           @relation("player2", fields: [player2Id], references: [id])
  player2Id     Int?
  // Used in team tournaments
  team1         Team?             @relation("team1", fields: [team1Id], references: [id])
  team1Id       Int?
  team2         Team?             @relation("team2", fields: [team2Id], references: [id])
  team2Id       Int?
  potentials    PotentialMatch[]
  playedMaps    PlayedMap[]
  bannedMaps    BannedMap[]
  inPredictions MatchPrediction[]
}

enum Opponent {
  opponent1
  opponent2
}

model PlayedMap {
  id          Int        @id @default(autoincrement())
  winner      Opponent?
  pickedBy    Opponent?
  match       Match      @relation(fields: [matchId], references: [lobbyId], onDelete: Cascade)
  matchId     Int
  pooledMap   PooledMap? @relation(fields: [pooledMapId], references: [id])
  pooledMapId Int?
}

model BannedMap {
  id          Int        @id @default(autoincrement())
  bannedBy    Opponent?
  match       Match      @relation(fields: [matchId], references: [lobbyId], onDelete: Cascade)
  matchId     Int
  pooledMap   PooledMap? @relation(fields: [pooledMapId], references: [id])
  pooledMapId Int?
}

// Potential match
model PotentialMatch {
  id           Int                        @id @default(autoincrement())
  localId      String                     @db.VarChar(5)
  date         DateTime
  match        Match                      @relation(fields: [matchId], references: [lobbyId], onDelete: Cascade)
  matchId      Int
  tournament   Tournament                 @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId Int
  // Used in solo tournaments
  player1      Player?                    @relation("potentialPlayer1", fields: [player1Id], references: [id])
  player1Id    Int?
  player2      Player?                    @relation("potentialPlayer2", fields: [player2Id], references: [id])
  player2Id    Int?
  // Used in team tournaments
  team1        Team?                      @relation("potentialTeam1", fields: [team1Id], references: [id])
  team1Id      Int?
  team2        Team?                      @relation("potentialTeam2", fields: [team2Id], references: [id])
  team2Id      Int?
  predictions  PotentialMatchPrediction[]

  @@unique([localId, tournamentId])
}

// Qualifiers
model QualLobby {
  lobby      Lobby           @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  lobbyId    Int             @id @unique
  teams      Team[]
  players    Player[]
  playedMaps PlayedQualMap[]
}

model PlayedQualMap {
  id                Int        @id @default(autoincrement())
  qualLobby         QualLobby  @relation(fields: [qualLobbyId], references: [lobbyId], onDelete: Cascade)
  qualLobbyId       Int
  teamsThatPlayed   Team[]
  playersThatPlayed Player[]
  pooledMap         PooledMap? @relation(fields: [pooledMapId], references: [id])
  pooledMapId       Int?
}

// Battle royale
model KnockoutLobby {
  lobby      Lobby               @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  lobbyId    Int                 @id @unique
  teams      Team[]
  players    Player[]
  playedMaps PlayedKnockoutMap[]
}

model PlayedKnockoutMap {
  id                Int           @id @default(autoincrement())
  knockoutLobby     KnockoutLobby @relation(fields: [knockoutLobbyId], references: [lobbyId], onDelete: Cascade)
  knockoutLobbyId   Int
  teamsThatPlayed   Team[]        @relation("playedTeams")
  knockedOutTeams   Team[]        @relation("knockedOutTeams")
  playersThatPlayed Player[]      @relation("playedPlayers")
  knockedOutPlayers Player[]      @relation("knockedOutPlayers")
  pooledMap         PooledMap?    @relation(fields: [pooledMapId], references: [id])
  pooledMapId       Int?
}

//   _____  _          _
//  / ____|| |        | |
// | (___  | |_  __ _ | |_  ___
//  \___ \ | __|/ _` || __|/ __|
//  ____) || |_| (_| || |_ \__ \
// |_____/  \__|\__,_| \__||___/
//

model ModMultiplier {
  id           Int        @id @default(autoincrement())
  mods         Mod[]
  value        Float
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId Int

  @@unique([tournamentId, mods])
}

model TeamScore {
  id           Int           @id @default(autoincrement())
  score        Int
  avgAccuracy  Float
  avgCombo     Int           @db.SmallInt
  relative     Float?        @db.DoublePrecision
  zScore       Float?        @db.DoublePrecision
  pooledMap    PooledMap     @relation(fields: [pooledMapId], references: [id], onDelete: Cascade)
  pooledMapId  Int
  round        Round         @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId      Int
  team         Team?         @relation(fields: [teamId], references: [id])
  teamId       Int?
  playerScores PlayerScore[]
}

model PlayerScore {
  id          Int        @id @default(autoincrement())
  score       Int
  accuracy    Float
  combo       Int        @db.SmallInt
  c300        Int        @db.SmallInt
  c100        Int        @db.SmallInt
  c50         Int        @db.SmallInt
  misses      Int        @db.SmallInt
  relative    Float?     @db.DoublePrecision
  zScore      Float?     @db.DoublePrecision
  mods        Mod[]
  pooledMap   PooledMap  @relation(fields: [pooledMapId], references: [id], onDelete: Cascade)
  pooledMapId Int
  round       Round      @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId     Int
  player      Player?    @relation(fields: [playerId], references: [id])
  playerId    Int?
  teamScore   TeamScore? @relation(fields: [teamScoreId], references: [id], onDelete: Cascade)
  teamScoreId Int?
}

//  _____  _        _
// |  __ \(_)      | |
// | |__) |_   ___ | | __ ___  _ __ ___   ___
// |  ___/| | / __|| |/ // _ \| '_ ` _ \ / __|
// | |    | || (__ |   <|  __/| | | | | |\__ \
// |_|    |_| \___||_|\_\\___||_| |_| |_||___/
//

model PickemUser {
  id           Int                    @id @default(autoincrement())
  points       Int                    @default(0) @db.SmallInt
  user         User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       Int
  tournament   Tournament             @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId Int
  submissions  PredictionSubmission[]

  @@unique([userId, tournamentId])
}

model PredictionSubmission {
  id                        Int                        @id @default(autoincrement())
  submittedAt               DateTime                   @default(now())
  tournament                Tournament                 @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  tournamentId              Int
  round                     Round                      @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId                   Int
  submittedBy               PickemUser                 @relation(fields: [submittedById], references: [id], onDelete: Cascade)
  submittedById             Int
  // Groups, swiss, single and double elim.
  matchPredictions          MatchPrediction[]
  potentialMatchPredictions PotentialMatchPrediction[]
  // Quals
  qualPredictions           QualPrediction[]
  // Battle royale tournaments can't have pickems

  @@unique([roundId, submittedById])
}

model MatchPrediction {
  id              Int                  @id @default(autoincrement())
  predictedWinner Opponent
  match           Match                @relation(fields: [matchId], references: [lobbyId], onDelete: Cascade)
  matchId         Int
  submission      PredictionSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  submissionId    Int

  @@unique([matchId, submissionId])
}

model PotentialMatchPrediction {
  id               Int                  @id @default(autoincrement())
  predictedWinner  Opponent
  potentialMatch   PotentialMatch       @relation(fields: [potentialMatchId], references: [id], onDelete: Cascade)
  potentialMatchId Int
  submission       PredictionSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  submissionId     Int

  @@unique([potentialMatchId, submissionId])
}

model QualPrediction {
  id                Int                  @id @default(autoincrement())
  predictedPosition Int                  @db.SmallInt
  // Solo
  player            Player?              @relation(fields: [playerId], references: [id])
  playerId          Int?
  // Teams
  team              Team?                @relation(fields: [teamId], references: [id])
  teamId            Int?
  submission        PredictionSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  submissionId      Int
}

//  __  __  _
// |  \/  |(_)
// | \  / | _  ___   ___
// | |\/| || |/ __| / __|
// | |  | || |\__ \| (__  _
// |_|  |_||_||___/ \___|(_)
//

model Issue {
  id              Int          @id @default(autoincrement())
  title           String       @db.VarChar(35)
  body            String
  type            IssueType
  imageCount      Int          @default(0) @db.SmallInt
  canContact      Boolean      @default(false) // Allow admins to contact the user through Discord if necessary?
  resolved        Boolean      @default(false)
  submittedBy     User?        @relation(fields: [submittedById], references: [id])
  submittedById   Int?
  inNotifications NotifIssue[]
}

enum IssueType {
  Security // Security vulnerability
  Enhancement
  NewFeature
  Bug
  Behavior // Inappropriate behavior
}

model Notification {
  id                   String                      @id @unique @db.Char(16) // ID will be generated with nanoid
  notifiedAt           DateTime                    @default(now())
  newIssue             NotifIssue?
  tournamentDeleted    NotifTournamentDeleted?
  gratedTournamentHost NotifGrantedTournamentHost?
  staffChange          NotifStaffChange?
  newStaffApp          NotifNewStaffApp?
  roundPublication     NotifRoundPublication?
  joinTeamRequest      NotifJoinTeamRequest?
  teamChange           NotifTeamChange?
  notifiedTo           User[]
}

// Notifies admins when a new issue is submitted or notifies the user who submitted the issue that the issue has been resolved
model NotifIssue {
  notifType      NotifIssueType
  notification   Notification   @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  notificationId String         @id @unique
  issue          Issue?         @relation(fields: [issueId], references: [id])
  issueId        Int?
}

enum NotifIssueType {
  Submission
  Resolved
}

// Notifies players and staff members that a tournament they were in has been deleted
model NotifTournamentDeleted {
  tournamentName String       @db.VarChar(50)
  notification   Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  notificationId String       @id @unique
  hostedBy       User?        @relation(fields: [hostedById], references: [id])
  hostedById     Int?
}

// Notifies the granted user when a user is granted the host role in a tournament
model NotifGrantedTournamentHost {
  notification   Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  notificationId String       @id @unique
  previousHost   User?        @relation("previousHost", fields: [previousHostId], references: [id])
  previousHostId Int?
  newHost        User         @relation("newHost", fields: [newHostId], references: [id], onDelete: Cascade)
  newHostId      Int
}

// Notifies a user when they're added to or removed from a tournament's staff team
model NotifStaffChange {
  action         NotifStaffChangeAction
  withRoles      String[]               @db.VarChar(25)
  notification   Notification           @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  notificationId String                 @id @unique
  user           User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         Int
}

enum NotifStaffChangeAction {
  Added
  Removed
}

// Notifies tournament staff members with the "MutateStaffMembers" permission when a tournament receives a new application from a user to join the staff team
model NotifNewStaffApp {
  notification   Notification      @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  notificationId String            @id @unique
  staffApp       StaffApplication? @relation(fields: [staffAppId], references: [id])
  staffAppId     Int?
}

// Notifies a team captain when a player has requested to be a part of their team
model NotifJoinTeamRequest {
  notification   Notification     @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  notificationId String           @id @unique
  request        JoinTeamRequest? @relation(fields: [requestId], references: [id])
  requestId      Int?
}

// Notifies a team's players and the joined/kicked player when a new player joins, leaves or gets kicked from the team
model NotifTeamChange {
  action         NotifTeamChangeAction
  notification   Notification          @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  notificationId String                @id @unique
  team           Team?                 @relation(fields: [teamId], references: [id])
  teamId         Int?
  affectedUser   User?                 @relation("affectedUser", fields: [affectedUserId], references: [id])
  affectedUserId Int?
  kickedBy       User?                 @relation("kicker", fields: [kickedById], references: [id])
  kickedById     Int?
}

enum NotifTeamChangeAction {
  Joined
  Leaved
  Kicked
}

// Notifies a tournament's players and staff members with the "MutateTournament" and "Host" permissions that the mappool, match schedules or statistics for a round has been made public
model NotifRoundPublication {
  publicized     NotifRoundPublicationType
  notification   Notification              @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  notificationId String                    @id @unique
  round          Round?                    @relation(fields: [roundId], references: [id])
  roundId        Int?
}

enum NotifRoundPublicationType {
  Mappool
  Schedules // Match schedules
  Statistics
}
